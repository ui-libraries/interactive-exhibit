<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Interactive Exhibit</title>
    <link rel="icon" href="data:," />
    <link rel="stylesheet" href="css/style.css" />
    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OBJLoader for Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <!-- MTLLoader for materials/textures with OBJ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <!-- GLTFLoader for modern PBR models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    
</head>
<body>
    <div id="app"></div>

    <script>
        // Slides data
        const slides = [
            {
                title: "The Remmelin",
                description: "A multi-layered anatomical illustration. Explore each layer by cycling through the images.",
                media: [
                    { type: "video", src: "assets/videos/remmelin/remmelin_man.mp4", loop: true },
                    { type: "video", src: "assets/videos/remmelin/remmelin_plate_clouds.mp4", loop: true },
                    { type: "video", src: "assets/videos/remmelin/remmelin_plate_eye.mp4", loop: true },
                    { type: "video", src: "assets/videos/remmelin/remmelin_plate_man.mp4", loop: true },
                    { type: "video", src: "assets/videos/remmelin/remmelin_plate_torso.mp4", loop: true },
                    { type: "video", src: "assets/videos/remmelin/remmelin_plate_woman.mp4", loop: true },
                    { type: "video", src: "assets/videos/remmelin/remmelin_woman.mp4", loop: true }
                ]
            },
            {
                title: "Fragmentos de Lluvia",
                description: "A poetic video work exploring the ephemeral nature of rain.",
                media: [
                    { type: "video", src: "assets/videos/fragmentos/fragmentos.mp4", loop: true }
                ]
            },
            {
                title: "Tunnel Book",
                description: "Interactive 3D model viewer. Drag to rotate, pinch to zoom.",
                media: [
                    { type: "3d", src: "assets/models/book.glb" }
                ]
            },
            {
                title: "The Deep",
                description: "A video journey into the mysterious depths of the ocean.",
                media: [
                    { type: "video", src: "assets/videos/thedeep/thedeep.mp4", loop: true }
                ]
            }
        ];

        // 3D Viewer function
        function init3DViewer(containerId, modelPath) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            if (typeof THREE === 'undefined') {
                console.error('Three.js not loaded');
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Three.js not loaded.</p>';
                return;
            }
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            if ('outputEncoding' in renderer && THREE.sRGBEncoding) {
                renderer.outputEncoding = THREE.sRGBEncoding;
            }
            
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0xf0f0f0);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);
            
            const objLoader = new THREE.OBJLoader();
            const mtlLoader = typeof THREE.MTLLoader !== 'undefined' ? new THREE.MTLLoader() : null;
            const gltfLoader = typeof THREE.GLTFLoader !== 'undefined' ? new THREE.GLTFLoader() : null;
            
            const manager = THREE.DefaultLoadingManager;
            manager.onError = (url) => console.warn('[3D] Asset load error:', url);
            
            let object;
            let currentDistance = 4;
            let initialPinchDistance = 0;
            let initialPinchZoom = 0;
            
            const finalizeWithObject = (container, loadedObject, scene, camera, renderer) => {
                container.innerHTML = '';
                container.appendChild(renderer.domElement);

                object = loadedObject;
                scene.add(object);
                
                const maxAnisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 8;
                object.traverse((node) => {
                    if (node && node.isMesh) {
                        const material = node.material;
                        if (Array.isArray(material)) {
                            material.forEach((m) => {
                                if (m && 'side' in m) m.side = THREE.DoubleSide;
                                if (m && m.map && 'encoding' in m.map && THREE.sRGBEncoding) m.map.encoding = THREE.sRGBEncoding;
                                if (m && m.map && 'anisotropy' in m.map) m.map.anisotropy = maxAnisotropy;
                                if (m) m.needsUpdate = true;
                            });
                        } else if (material) {
                            if ('side' in material) material.side = THREE.DoubleSide;
                            if (material.map && 'encoding' in material.map && THREE.sRGBEncoding) material.map.encoding = THREE.sRGBEncoding;
                            if (material.map && 'anisotropy' in material.map) material.map.anisotropy = maxAnisotropy;
                            material.needsUpdate = true;
                        }
                    }
                });

                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 5 / maxDim;
                object.scale.setScalar(scale);
                object.position.sub(center.multiplyScalar(scale));

                camera.position.z = currentDistance;

                function animate() {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                }
                animate();

                let isMouseDown = false;
                let mouseX = 0, mouseY = 0;

                container.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });

                container.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });

                container.addEventListener('mousemove', (e) => {
                    if (isMouseDown) {
                        const deltaX = e.clientX - mouseX;
                        const deltaY = e.clientY - mouseY;

                        object.rotation.y += deltaX * 0.01;
                        object.rotation.x += deltaY * 0.01;

                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }
                });

                container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const zoomDelta = e.deltaY > 0 ? 1 : -1;

                    currentDistance += zoomDelta * zoomSpeed * currentDistance;
                    currentDistance = Math.max(1, Math.min(20, currentDistance));

                    camera.position.z = currentDistance;
                });

                let touchStartX = 0, touchStartY = 0;
                let touchCount = 0;

                container.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchCount = e.touches.length;

                    if (touchCount === 1) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    } else if (touchCount === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        initialPinchDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        initialPinchZoom = currentDistance;
                    }
                });

                container.addEventListener('touchend', () => {
                    touchCount = 0;
                });

                container.addEventListener('touchmove', (e) => {
                    e.preventDefault();

                    if (touchCount === 1) {
                        const deltaX = e.touches[0].clientX - touchStartX;
                        const deltaY = e.touches[0].clientY - touchStartY;

                        object.rotation.y += deltaX * 0.01;
                        object.rotation.x += deltaY * 0.01;

                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    } else if (touchCount === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentPinchDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );

                        if (initialPinchDistance > 0) {
                            const pinchRatio = initialPinchDistance / currentPinchDistance;
                            currentDistance = initialPinchZoom * pinchRatio;
                            currentDistance = Math.max(1, Math.min(20, currentDistance));
                            camera.position.z = currentDistance;
                        }
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (container.contains(document.activeElement) || container === document.activeElement) {
                        const zoomSpeed = 0.5;

                        if (e.key === 'z' || e.key === 'Z') {
                            currentDistance -= zoomSpeed;
                            currentDistance = Math.max(1, currentDistance);
                            camera.position.z = currentDistance;
                        } else if (e.key === 'x' || e.key === 'X') {
                            currentDistance += zoomSpeed;
                            currentDistance = Math.min(20, currentDistance);
                            camera.position.z = currentDistance;
                        }
                    }
                });

                const instructions = document.createElement('div');
                instructions.className = 'viewer-hint';
                instructions.innerHTML = 'Drag: Rotate | Pinch: Zoom | Mouse wheel: Zoom | Z/X: Zoom';
                container.appendChild(instructions);
            };
            
            const loadGLTF = () => {
                if (!gltfLoader) {
                    console.error('GLTFLoader not available');
                    loadObjOnly();
                    return;
                }
                
                gltfLoader.load(
                    modelPath,
                    (gltf) => {
                        console.log('[3D] GLTF loaded successfully:', gltf);
                        finalizeWithObject(container, gltf.scene, scene, camera, renderer);
                    },
                    (progress) => {
                        console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('Error loading GLTF model:', error);
                        loadObjOnly();
                    }
                );
            };

            const loadObjOnly = () => {
                objLoader.load(
                    modelPath,
                    (loadedObject) => {
                        finalizeWithObject(container, loadedObject, scene, camera, renderer);
                    },
                    (progress) => {
                        console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                    },
                    (error) => {
                        console.error('Error loading 3D model:', error);
                        container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Error loading 3D model. Please check the file path.</p>';
                    }
                );
            };

            const tryLoadWithMtl = () => {
                if (!mtlLoader || !/\.obj$/i.test(modelPath)) {
                    loadObjOnly();
                    return;
                }
                const mtlPath = modelPath.replace(/\.obj$/i, '.mtl') + `?v=${Date.now()}`;
                const resourceBase = modelPath.substring(0, modelPath.lastIndexOf('/') + 1);
                try {
                    const manager = (mtlLoader.manager) || THREE.DefaultLoadingManager;
                    const previousModifier = manager._urlModifier || null;
                    manager.setURLModifier((url) => {
                        const base = resourceBase;
                        const u = url.split('?')[0];
                        const filename = u.split(/[/\\]/).pop();
                        const rewritten = base + filename;
                        const cacheBust = `v=${Date.now()}`;
                        return rewritten + (rewritten.includes('?') ? `&${cacheBust}` : `?${cacheBust}`);
                    });
                    if (typeof mtlLoader.setPath === 'function') {
                        mtlLoader.setPath(resourceBase);
                    }
                    mtlLoader.setResourcePath(resourceBase);
                    if (typeof mtlLoader.setTexturePath === 'function') {
                        mtlLoader.setTexturePath(resourceBase);
                    }
                    mtlLoader.load(
                        mtlPath,
                        (materials) => {
                            if (materials && materials.materialsInfo) {
                                console.log('[3D] MTL materialsInfo:', JSON.parse(JSON.stringify(materials.materialsInfo)));
                            }
                            try { materials.preload(); } catch (_) {}
                            objLoader.setMaterials(materials);
                            loadObjOnly();
                        },
                        undefined,
                        () => {
                            if (previousModifier) manager.setURLModifier(previousModifier);
                            loadObjOnly();
                        }
                    );
                } catch (_) {
                    loadObjOnly();
                }
            };
            
            // Determine loader based on file extension
            if (/\.(glb|gltf)$/i.test(modelPath)) {
                loadGLTF();
            } else if (/\.obj$/i.test(modelPath)) {
                tryLoadWithMtl();
            } else {
                console.error('Unsupported file format:', modelPath);
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Unsupported file format. Please use .obj, .glb, or .gltf files.</p>';
            }
        }

        // Main app logic
        const app = document.getElementById('app');
        let currentSlide = 0;
        let currentMedia = 0;

        function render() {
            const slide = slides[currentSlide];
            const mediaItem = slide.media[currentMedia];

            let mediaHtml = '';
            if (mediaItem.type === 'image') {
                mediaHtml = `<img class="media-asset" src="${mediaItem.src}" alt="${slide.title}" />`;
                            } else if (mediaItem.type === 'video') {
                    const loopAttr = mediaItem.loop ? 'loop' : '';
                    const volumeAttr = mediaItem.src.includes('thedeep.mp4') ? 'data-volume="0.7"' : '';
                    mediaHtml = `<video class="media-asset" src="${mediaItem.src}" controls autoplay preload="auto" width="100%" height="100%" ${loopAttr} ${volumeAttr}></video>`;
            } else if (mediaItem.type === 'youtube') {
                mediaHtml = `
                    <iframe
                        class="media-asset"
                        width="100%"
                        height="100%"
                        src="https://www.youtube.com/embed/${mediaItem.src}?autoplay=1&controls=1&rel=0"
                        title="YouTube video player"
                        frameborder="0"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen
                    ></iframe>
                `;
            } else if (mediaItem.type === '3d') {
                mediaHtml = `
                    <div id="3d-container" class="three-container">
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: white;">
                            <div style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;"></div>
                            <div style="font-size: 18px; font-weight: 500;">Loading 3D Model...</div>
                            <div style="font-size: 14px; opacity: 0.8; margin-top: 8px;">This may take a few moments</div>
                        </div>
                        <style>
                            @keyframes spin {
                                0% { transform: rotate(0deg); }
                                100% { transform: rotate(360deg); }
                            }
                        </style>
                    </div>
                `;
            }

            app.innerHTML = `
                <div class="split-container">
                    <div class="logo-container">
                        <img src="assets/images/logo.png" alt="Logo" />
                    </div>
                    <div class="media-side">
                        <div class="media-display">
                            ${mediaHtml}
                        </div>
                        <div class="desc-container">
                            <button id="prev-slide">
                                <img src="assets/images/back-button.svg" alt="Previous Work" />
                            </button>
                            <div class="desc-content">
                                <h2>${slide.title}</h2>
                                <p>${slide.description}</p>
                                <div class="slide-controls">
                                    <span class="counter">Work ${currentSlide + 1} of ${slides.length}</span>
                                </div>
                            </div>
                            <button id="next-slide">
                                <img src="assets/images/next-button.svg" alt="Next Work" />
                            </button>
                        </div>
                    </div>
                </div>
            `;

            if (mediaItem.type === '3d') {
                setTimeout(() => {
                    console.log('[App] Initializing 3D viewer for:', mediaItem.src);
                    init3DViewer('3d-container', mediaItem.src);
                }, 100);
            }
            
            // Set volume for specific videos after they load
            if (mediaItem.type === 'video') {
                setTimeout(() => {
                    const video = document.querySelector('.media-asset');
                    if (video && video.tagName === 'VIDEO') {
                        if (mediaItem.src.includes('thedeep.mp4')) {
                            video.volume = 0.7; // 30% lower volume
                        }
                    }
                }, 200);
            }
            


            // Note: Media controls are not included in the current layout
            // Only slide navigation controls are used

            document.getElementById('prev-slide').onclick = () => {
                currentSlide = (currentSlide - 1 + slides.length) % slides.length;
                currentMedia = 0;
                render();
            };
            document.getElementById('next-slide').onclick = () => {
                currentSlide = (currentSlide + 1) % slides.length;
                currentMedia = 0;
                render();
            };
        }

        // Start the app
        render();
    </script>
</body>
</html> 